(** * Generic Definitions for the Representation Predicates

 Kathrin Stark, 2020. 

  This code contains definitions to later on generate specific instances of representation predicates.

  This document contains of the following parts: 
  - 1. Import of necessary definitions from Shengyi/Olivier. The CertiCoq code cannot be imported at the moment because of problems compiling both projects at the same time. 
  - 2. The definition of rep_type, the type to describe a node either in the graph or outside, and its connection to field. 
  - 3. The graph_cRep predicate which will be the central part of later specific instances. 
  - 4. Examples on how this predicate will be used in the representation predicate for bool, nat, and list. 
*)

Require Export VST.floyd.proofauto.
Require Export CertiGraph.CertiGC.gc_spec.
Require Export CertiGraph.CertiGC.GCGraph.
Require Export CertiGraph.CertiGC.spatial_gcgraph. 


(** ** 1. Import of the necessary definitions *) 

(** Type of graphs, according to Shengyi's garbage collector proof. *)
Definition graph := LGraph.

(** ***  Definitions from the CertiCoq Project. *)

(** Representation of unboxed values. *) 
Definition repr_unboxed_L7: N -> Z -> Prop :=
   fun t => fun h =>
              (h = (Z.shiftl (Z.of_N t) 1) + 1)%Z /\
              (0 <= (Z.of_N t)  <  Ptrofs.half_modulus )%Z.

(** Representation of the boxed header, given the tag byte and the size of the data. *) 
Definition boxed_header: N -> N -> Z -> Prop :=
  fun t => fun a =>  fun h =>
                       (h =  (Z.shiftl (Z.of_N a) 10) + (Z.of_N t))%Z /\
                       (0 <= Z.of_N t <  Zpower.two_power_pos 8)%Z /\
                       (0 <= Z.of_N a <  Zpower.two_power_nat (Ptrofs.wordsize - 10))%Z.

Definition int_chunk := if Archi.ptr64 then Mint64 else Mint32.
Definition int_size := (size_chunk int_chunk).

(** Internal representation of a constructor, where enum t describes a constructor with tag t, and boxed t n is a boxed value with tag t and n arguments. *) 
Inductive cRep : Set := enum : N -> cRep | boxed : N -> N -> cRep.


(** ** 2. Representation type *)

(** Type of representation values, rep_type:

   Either Z, a value representing an unboxed value,
   or GC_Pointer, a pointer outside the garbage-collected heap,
   (Inductive GC_Pointer : Type :=  GCPtr : block -> ptrofs -> GC_Pointer)
   or VType, a node in the graph.

   Values generated by the code generator never point outside the garbage-collected heap, 
   but later C code might do this. *)

Inductive rep_type :=
  | repZ : Z -> rep_type 
  | repOut : GC_Pointer -> rep_type                
  | repNode : VType -> rep_type.                            

(** Conversion functions between raw_field, the representation type of fields in Shengyi's graphs, and our rep_type from outside.

raw_field = option (Z + GC_Pointer)
Meaning: Z and GC_Pointer have the same meaning as in rep_type. 
The empty option case denotes the case that we have a pointer to another node in the graph, denoted by an edge.

The Z and GC_Pointer case are straightforward. 
In make_field_t we have additionally the graph g, 
and the node v and the nth argument we are coming from.
Given this information, we can determine the goal node.
 *) 

Definition field_rep (g : graph) (v : VType) (n : nat) (raw : raw_field) : rep_type := ( 
  match raw with 
 | None => repNode (dst g (v, n)) 
 | Some (inl z) => repZ z
 | Some (inr p) => repOut p
end). 

Definition rep_field (x : rep_type) : raw_field := 
  match x with 
  | repZ z => Some (inl z)
  | repOut p => Some (inr p) 
  | repNode _ => None
end.


(** ** 3. The graph_cRep predicate *) 

(** Predicate to state that a list of raw_field and a list of rep_type are compatible. 
 This is needed for the fitting_index predicate below. 
 
 Needed, as the information of a raw_field just makes sense together with the graph and the position.
*) 
Inductive compatible (g : graph) (v : VType) ( n : nat) : list raw_field -> list rep_type -> Prop :=
| compatible_nil : compatible g v n nil nil
| compatible_cons x xs y ys : compatible g v (S n) xs ys -> field_rep g v n x = y -> compatible g v n (x :: xs) (y :: ys). 


(** Parametric predicate to be used in combination with the generated code. 
    graph_cRep g p c args states that in graph g, p : rep_type corresponds to the value with the constructor described by c and with arguments args.

    Two cases: 
    - If we describe an unboxed constructor enum t with tag t, then the list of arguments has to be empty and the representation of the tag has to fit with the actual value z according to the relation repr_unboxed_L7. 
    - If we describe a boxed constructor boxed t n with tag t and length n, 
      then we describe a node repNode v in the graph and 
      1. the length of the arguments arrays has to coincide with the number given in the constructor description, 
      2. the given graph g has to actually contain the node v, 
      3. the label of v in the graph g has to coincide with the information we have given, using the predicate compatible.

   TODO: 
   - Do we want the args computational in the first case?
 **)

Definition graph_cRep (g: graph) (p : rep_type) (c : cRep) (args: list rep_type) : Prop :=
match c, p with 
 | enum t, repZ z => args = nil /\ (* repr_unboxed_L7 t z *) Z.to_N z = t
 | boxed t n, repNode v => length args = N.to_nat n /\ graph_has_v g v /\
                              match (vlabel g v) with  
                                | Build_raw_vertex_block false v' raws 0 n _ _ _ _ => v = v' /\ n = Z_of_N' t /\ compatible g v 0 raws args
                                | _ => False                                               
                              end
 | _, _ => False
end.


(** We will later use the following predicate actually spatially representing a graph: 
graph_rep : LGraph -> mpred*)

(** ** 4. Examples of using the graph_cRep predicate for bool/nat. *)

Section Tests. 

(* Showcase what these definitions mean in the specific case.
Similar tags and the fixpoints will be generated by Joomy's code generation. 
*)

Definition tag_bool (b : bool) : cRep := 
match b with 
| true => enum 0  
| false => enum 1
end.

Fixpoint bool_in_graph (g : graph) (b : bool) (p : rep_type) : Prop :=
  match b with 
  | true => graph_cRep g p (tag_bool true) nil
  | false => graph_cRep g p (tag_bool false) nil
end.

Definition tag_nat (n : nat) : cRep := 
match n with 
| O => enum 0  
| S _ => boxed 0 1
end.

Fixpoint nat_in_graph (g : graph) (n : nat) (p : rep_type) : Prop :=
  match n with 
  | O => graph_cRep g p (tag_nat 0) nil
  | S n' => exists p1, nat_in_graph g n' p1 /\ graph_cRep g p (tag_nat (S n')) (p1 :: nil)
end.

Variable g : graph. 

(** This is true independent of the graph and always reduces to a true equation.
*) 
Goal (nat_in_graph g 0 (repZ 0)). 
Proof. 
  cbv. intuition congruence. 
Qed. 

Goal forall n v, nat_in_graph g (S n) v -> exists v', nat_in_graph g n v'. 
Proof. 
  intros n v (p1&H1&H2). eauto. 
Qed.

Variable v : VType. 

Goal (nat_in_graph g 1) (repNode v). 
Proof. 
  cbn. 
  exists (repZ 0). 
  intuition (try congruence). 
  (** This is the point where we can't influence anything anymore, but the graph has to contain the respective information. *)

  (* TODO: Can I have it more constructive to get p1? 
     Do we want to tactics to simplify this kind of proofs?
     Do we want to give more hints to unfold things?
*)
Abort.

Definition tag_list {X} (xs : list X): cRep :=
match xs with 
  | nil => enum 0 
  | _ => boxed 0 2
end.

(* TODO: Use type classes for arguments? *)
Fixpoint list_in_graph {X: Type} (X_in_graph : graph -> X -> rep_type -> Prop) (g : graph) (xs : list X) (p : rep_type) := 
match xs with 
| nil => graph_cRep g p (tag_list (@nil X)) nil
| cons x xs' => exists p1 p2, X_in_graph g x p1 /\ list_in_graph X_in_graph g xs' p2 /\ graph_cRep g p (tag_list (cons x xs)) (p1 :: p2 :: nil)
end.

Goal (list_in_graph nat_in_graph g (O :: nil)) (repNode v). 
Proof. 
  cbn. 
  exists (repZ 0). (* For the 0 *)
  exists (repZ 0). (* For nil *)
  intuition (try congruence). 
  - (** We need that the vertex v indeed exists. *) 
    admit. 
  - (** We need that the vertex satisfies corresponding properties. *) 
Abort.

End Tests.

